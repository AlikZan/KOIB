using System; 

using System.Reflection; 

using System.Text; 

using System.Text.RegularExpressions; 

using System.Xml.Serialization; 

 

 

namespace Croc.Bpc.Election.Voting 

{ 

    /// <summary> 

    /// ??????????? ???????????. 

    /// </summary> 

    [Serializable, XmlType("Check")] 

    public class CheckExpression 

    { 

        /// <summary> 

        /// ??????? ???????? ???????????? ??????????? 

        /// </summary> 

        [XmlAttribute("expression")] 

        public string m_sExpression; 

 

 

        /// <summary> 

        /// ???????? ?? ??????????? ??????????? 

        /// </summary> 

        [XmlAttribute("enabled")] 

        public bool Enabled; 

 

 

        /// <summary> 

        /// ??????? ??????????? ("???????") ?? 

        /// </summary> 

        [XmlAttribute("mild")] 

        public bool Mild; 

 

 

        /// <summary> 

        /// ????? ?????? ?????? ?? ???????? 

        /// </summary> 

        protected ProtocolTemplate _template = null; 

 

 

		/// <summary> 

		/// ??????????? ?? ??????????? 

		/// </summary> 

		[XmlIgnore] 

		public bool Failed 

		{ 

			get; 

			set; 


		} 

 

 

		/// <summary> 

		/// ????????? ? ??????????? ???????? ????? 

		/// </summary> 

		[XmlIgnore] 

		public string Expression 

		{ 

			get 

			{ 

				//  ??????? ??? ???? ? ?? 

				return m_sExpression + " * ?????? ??????????"; 

			} 

		} 

 

 

        ///// <summary> 

        ///// ????????? ??????????? ??????????? 

        ///// </summary> 

		public bool Check(ProtocolTemplate oProtocol) 

		{ 

			_template = oProtocol; 

			if (!Enabled) return true; 

 

 

			// ??????? ????? ??????????? ?? 

			if (_method == null) 

				this.BindMethod(Assembly.GetExecutingAssembly()); 

 

 

			Failed = !(bool)_method.Invoke(null, null); 

 

 

			return !Failed; 

		} 

 

 

		#region ?????? ??? ???????? / ???????????? ?????? ???????? ?? ? ???????????? ?????? 

 

 

		/// <summary> 

        /// ?????? ?? ?????? ??????? 

        /// </summary> 

        const string REGEX_LINE_REFERENCES = @"(\[\d+\w*\])|S|M|P"; 

 

 

        /// <summary> 

        /// ???????? ????? ?????? ?????? 

        /// </summary> 


        const string REGEX_LINE_NUMBER = @"\A\d+"; 

 

 

        /// <summary> 

        /// ?????????????? ????? ?????? ?????? 

        /// </summary> 

        const string REGEX_LINE_ADD_NUMBER = @"\D*\Z"; 

 

 

        /// <summary> 

        /// ?????? ??????????? ???????????? ?????? 

        /// </summary> 

        const string ASSEMBLY_BEGIN = @"public class ExpressionChecker_SUFFIX{static public bool check(){return "; 

        /// <summary> 

        /// ????? ??????????? ???????????? ?????? 

        /// </summary> 

        const string ASSEMBLY_END = @";}}"; 

 

 

        /// <summary> 

        /// ???????????????? ?????, ??????????? ?? 

        /// </summary> 

        [NonSerialized] 

        private MethodInfo _method = null; 

 

 

        /// <summary> 

        /// ????????? ????????? ?????? ??? ????????? 

        /// </summary> 

        /// <param name="oProtocol">?????? ?? ????????</param> 

        /// <returns>????? ??????, ??? null, ???? ?? ?????????</returns> 

        public string BuildCheckTypeText(ProtocolTemplate oProtocol) 

        { 

            try 

            { 

                _template = oProtocol; 

 

 

				// ?????? ??? ?????? ? ?????????? ?????????? 

                Regex oRegExpression; 

				// ???????? ?????????? ? ????????? 

                MatchCollection oMatches; 

				// ???????? ????? ?? ???????. 

                string sFullKey; 

 

 

                // ????????? ??????? ????? ????????????? 

                StringBuilder sPreparedExpression = new StringBuilder(m_sExpression); //?????????, ? ???????????? ????????????? 

 

 


                // ?????? ???? ? ???????? ????????? ??? ?????? ???? [xxyy] 

                // ???????? ?? ??????????????? ?? ???????? ?????. 

                oRegExpression = new Regex(REGEX_LINE_REFERENCES); 

                oMatches = oRegExpression.Matches(m_sExpression); 

 

 

                // ????????? ?????????? ??? ?????????? ?????? ????? ?????? 

                int nDelta = 0; 

                foreach (Match oMatch in oMatches) 

                { 

					string sNewValue; 

                    switch (oMatch.Value) 

                    { 

                        case "S": 

							// ???????? ??? ??? ??????? ???????? 

							sNewValue = String.Format( 

								"Managers.ElectionManager.VotingResults.GetTotalVotesCount(\"{0}\")", 

								oProtocol.ElectionLink.ElectionId); 

							break; 

						case "M": 

							// ????? ??????? ? ?????? ???????: 

							sNewValue = _template.ElectionLink.MaxMarks.ToString(); 

							break; 

						case "P": 

							// ???????? ??? ??? ??????? ???????? 

							sNewValue = String.Format( 

								"Managers.ElectionManager.VotingResults.GetAboveCandidateVotesCount(" 

									+ "Managers.ElectionManager.SourceData.GetElectionByNum(\"{0}\"))", 

								oProtocol.ElectionLink.ElectionId); 

							break; 

 

 

                        default: 

                            sFullKey = oMatch.Value; 

                            sFullKey = sFullKey.TrimStart('['); 

                            sFullKey = sFullKey.TrimEnd(']'); 

 

 

                            int nLine = Convert.ToInt32(sFullKey); 

                            if (nLine < 1 || nLine > oProtocol.Lines.Length) 

                                throw new Exception("? ????????? ??? ?????? ? ?????????? ??????? " + nLine); 

 

 

                            // ??????? ??? ??????? ? ??????????? 

							sNewValue = String.Format( 

								"Managers.ElectionManager.SourceData.GetElectionByNum(\"{0}\").Protocol.Lines[{1}].Value" 

								, oProtocol.ElectionLink.ElectionId 

								, nLine - 1); 

                            break; 

                    } 


 
 

					// ????????: 

					// ??????? ???????? - ????????????, ??? ????????? ???????????? ????????? ?? ?????? 

					sPreparedExpression.Replace(oMatch.Value, sNewValue, oMatch.Index + nDelta, oMatch.Length); 

					nDelta += sNewValue.Length - oMatch.Length; 

				} 

 

 

                //????????? ???? ????????? ? ????????? ??????????, ??? ?????????? ????? ? ??????????: 

                sPreparedExpression.Replace("=", "@"); 

                //?????? ???????????: 

                sPreparedExpression.Replace("<@", " " + "<=" + " "); 

                sPreparedExpression.Replace(">@", " " + ">=" + " "); 

                sPreparedExpression.Replace("@", " " + "==" + " "); 

                // ?.?. ???? ???????? ? ????, ??????? ????? ?????????? C#-??, ? ??????? 

                // ??????????? VB, ?? ???? ?? ???? ????????: 

				// ???????? "?? ?????" 

                sPreparedExpression.Replace("<>", " " + "!=" + " "); 

 

 

                //?????? ? ??? ???? ??????????? ?????????. ???? ????????????? ???????????? ??????: 

                sPreparedExpression.Insert(0, ASSEMBLY_BEGIN.Replace( 

					"_SUFFIX" 

					, GetExpressionCheckerSuffix())); 

                sPreparedExpression.Append(ASSEMBLY_END); 

 

 

                return sPreparedExpression.ToString(); 

            } 

            catch (Exception ex) 

            { 

                throw new Exception( 

					String.Format( 

						"?????? ?????? ? ????????? : {0}:\n{1}" 

						,m_sExpression 

						,ex.Message) 

					, ex); 

            } 

        } 

 

 

        /// <summary> 

        /// ???????? ????????? ? ??????????????? ??? ???? 

        /// </summary> 

        /// <param name="oAssembly">?????? ?? ?????? ? ????? ????? ?????????</param> 

        public void BindMethod(Assembly oAssembly) 

        { 

            const string CHECK_METHOD = "check"; //?????, ??????????? ????????? ?????? 

            // ???????????? ????????????? ???? ??? ???????? ????????? 


            const string CHECKER_TYPE_NAME = "Croc.Bpc.DynamicTypes.ExpressionChecker"; 

 

 

            try 

            { 

                string sCheckTypeName; //??? ???????????? ?????? 

                System.Type oCheckerType; //??????????? ?????? 

 

 

                //?????????? ?????????? ??? ?????? [name_<?????????? ???>]: 

                sCheckTypeName = CHECKER_TYPE_NAME + GetExpressionCheckerSuffix(); 

 

 

                //??????? ???: 

                oCheckerType = oAssembly.GetType(sCheckTypeName, true, false); 

 

 

                //??????? ?????: 

                _method = oCheckerType.GetMethod(CHECK_METHOD); 

            } 

            catch (Exception ex) 

            { 

                throw new Exception("?????? ?????????? ???  ?????????:" + m_sExpression + ":\n" + ex.Message, ex); 

            } 

        } 

 

 

		/// <summary> 

		/// ???????? ??????? ?????? ??? ???????? ??????????? ????????? 

		/// </summary> 

		/// <returns>???????</returns> 

		private string GetExpressionCheckerSuffix() 

		{ 

			return String.Format( 

				"_{0}_{1}", 

				_template.ElectionLink.ElectionId, 

				m_sExpression.GetHashCode().ToString().Replace("-", "_")); 

		} 

 

 

		#endregion 

 

 

		/// <summary> 

		/// ? ??????????? ??????????? ???????? ?????????? ?????? ????? ?? ?? ?????? ??? 

		/// (Line.Num + Line.AdditionalNum) 

		/// </summary> 

		/// <param name="oProtocol">????????</param> 

		/// <returns></returns> 

		public string GetExpansion(ProtocolTemplate oProtocol) 


		{ 

			try 

			{ 

				// ?????? ??? ?????? ? ?????????? ?????????? 

				Regex oRegExpression; 

				// ???????? ?????????? ? ????????? 

				MatchCollection oMatches; 

				// ???????? ????? ?? ???????. 

				string sFullKey; 

 

 

				// ????????? ??????? ????? ????????????? 

				StringBuilder sPreparedExpression = new StringBuilder(m_sExpression); 

 

 

				// ?????? ???? ? ???????? ????????? ??? ?????? ???? [xxyy] 

				// ???????? ?? ??????????????? ?? ???????? ?????. 

				oRegExpression = new Regex(REGEX_LINE_REFERENCES); 

				oMatches = oRegExpression.Matches(this.m_sExpression); 

 

 

				// ????????? ?????????? ??? ?????????? ?????? ????? ?????? 

				int nDelta = 0; 

				foreach (Match oMatch in oMatches) 

				{ 

					if (oMatch.Value.StartsWith("[")) 

					{ 

						sFullKey = oMatch.Value; 

						sFullKey = sFullKey.TrimStart('['); 

						sFullKey = sFullKey.TrimEnd(']'); 

 

 

						int nLine = Convert.ToInt32(sFullKey); 

						if (nLine < 1 || nLine > oProtocol.Lines.Length) 

							throw new Exception("? ????????? ??? ?????? ? ?????????? ??????? " + nLine); 

 

 

						// ??????? ???????? ?????? 

						var sNewValue = "[" + oProtocol.Lines[nLine - 1].Num + oProtocol.Lines[nLine - 1].AdditionalNum + "]"; 

 

 

						// ????????: 

						// ??????? ???????? - ????????????, ??? ????????? ???????????? ????????? ?? ?????? 

						sPreparedExpression.Replace(oMatch.Value, sNewValue, oMatch.Index + nDelta, oMatch.Length); 

						nDelta += sNewValue.Length - oMatch.Length; 

					} 

 

 

				} 

 


 
				return sPreparedExpression.ToString(); 

			} 

			catch (Exception ex) 

			{ 

				throw new Exception( 

					String.Format("?????? ?? \"{0}\". ?????? ? {1}:\n{2}" 

						,m_sExpression 

						,oProtocol.ElectionLink.ElectionId 

						,ex.Message) 

					,ex); 

			} 

		} 

 

 

		/// <summary> 

		/// ???????? ??? ???????? ? ?? ????????? ?? ?? ????????? ???????? 

		/// </summary> 

		/// <param name="oProtocol">????????</param> 

		/// <param name="results">?????????? ???????????</param> 

		/// <returns></returns> 

		public string GetFullExpression(ProtocolTemplate oProtocol, VotingResults results) 

		{ 

			try 

			{ 

				_template = oProtocol; 

				Regex oRegExpression; //?????? ??? ?????? ? ?????????? ?????????? 

				MatchCollection oMatches;	//???????? ?????????? ? ????????? 

				string sFullKey;	//???????? ????? ?? ???????. 

 

 

				// ????????? ??????? ????? ????????????? 

				StringBuilder sPreparedExpression = new StringBuilder(this.m_sExpression); //?????????, ? ???????????? ????????????? 

 

 

				// ?????? ???? ? ???????? ????????? ??? ?????? ???? [xxyy] 

				// ???????? ?? ??????????????? ?? ???????? ?????. 

				oRegExpression = new Regex(REGEX_LINE_REFERENCES); 

				oMatches = oRegExpression.Matches(this.m_sExpression); 

 

 

				// ????????? ?????????? ??? ?????????? ?????? ????? ?????? 

				int nDelta = 0; 

				foreach (Match oMatch in oMatches) 

				{ 

					string sNewValue = null; 

					switch (oMatch.Value) 

					{ 

						case "S": 

							sNewValue = results.GetTotalVotesCount(oProtocol.ElectionLink.ElectionId).ToString(); 


							break; 

						case "M": 

							sNewValue = oProtocol.ElectionLink.MaxMarks.ToString(); 

							break; 

						case "P": 

							sNewValue = results.GetAboveCandidateVotesCount(oProtocol.ElectionLink).ToString(); 

							break; 

 

 

						default: 

							sFullKey = oMatch.Value; 

							sFullKey = sFullKey.TrimStart('['); 

							sFullKey = sFullKey.TrimEnd(']'); 

 

 

							int nLine = Convert.ToInt32(sFullKey); 

							if (nLine < 1 || nLine > oProtocol.Lines.Length) 

								throw new Exception("? ????????? ??? ?????? ? ?????????? ??????? " + nLine); 

 

 

							// ??????? ???????? ?????? ????????? 

							if (oProtocol.Lines[nLine - 1].Value.HasValue) 

								sNewValue = oProtocol.Lines[nLine - 1].Value.ToString(); 

							else 

								throw new Exception("?? ????????? ?????? ????????? ????? " + nLine); 

							break; 

					} 

 

 

					// ????????: 

					// ??????? ???????? - ????????????, ??? ????????? ???????????? ????????? ?? ?????? 

					sPreparedExpression.Replace(oMatch.Value, sNewValue, oMatch.Index + nDelta, oMatch.Length); 

					nDelta += sNewValue.Length - oMatch.Length; 

				} 

 

 

				return sPreparedExpression.ToString(); 

			} 

			catch (Exception ex) 

			{ 

				throw new Exception( 

					String.Format("?????? ?? \"{0}\". ?????? ? {1}:\n{2}" 

						, m_sExpression 

						, oProtocol.ElectionLink.ElectionId 

						, ex.Message) 

					, ex); 

			} 

		} 

 

 


        /// <summary> 

        /// ????????? ????????????? ??????? 

        /// </summary> 

        /// <returns></returns> 

        public override string ToString() 

        { 

            return "[m_sExpression=" + m_sExpression + 

                    ",Enabled=" + Enabled.ToString() + 

                    "Mild=" + Mild.ToString() + "]"; 

        } 

    } 

}


