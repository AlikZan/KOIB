using System; 

using System.Collections.Generic; 

using System.Threading; 

using Croc.Core.Diagnostics.Default; 

using Croc.Core.Utils.Collections; 

 

 

namespace Croc.Core.Diagnostics 

{ 

	/// <summary> 

	/// ?????? ?????????? <see cref="ICoreApplication"/>. 

	/// </summary> 

	internal class Logger : ILogger, IDisposable 

	{ 

        /// <summary> 

        /// ??????? ??????? 

        /// </summary> 

		private readonly BlockingQueue<LoggerEvent> _queue; 

        /// <summary> 

        /// ??????? ???????????? ?????????????? 

        /// </summary> 

		private volatile Boolean _bAsync; 

        /// <summary> 

        /// ???????, ????????????? ?? ??????? 

        /// </summary> 

	    private List<IEventFilter> _filters = new List<IEventFilter>(); 

        /// <summary> 

        /// ?????? ?????????? ?? ?????? ??????? 

        /// </summary> 

	    private IEventFilter _traceLevelFilter; 

        /// <summary> 

        /// ????? ????????? ??????? 

        /// </summary> 

        Thread _thread = null; 

        /// <summary> 

        /// ???????? 

        /// </summary> 

		Logger _parentLogger; 

 

 

        /// <summary> 

        /// ??? ??????? 

        /// </summary> 

        public string LoggerName 

        { 

            get; 

            private set; 

        } 

 

 


        /// <summary> 

		/// ctor 

		/// </summary> 

		/// <param name="loggerName">??? ???????</param> 

        /// <param name="filter">??????? ?? ?????????</param> 

        /// <param name="parentLogger">???????????? ??????</param> 

        /// <param name="queueEnabledEvent">??????? ????????????/????????????? ?????? ? ???????</param> 

        public Logger(string loggerName, IEventFilter filter, Logger parentLogger, ManualResetEvent queueEnabledEvent) 

		{ 

            CodeContract.Requires(!string.IsNullOrEmpty(loggerName)); 

 

 

            _queueEnabledEvent = queueEnabledEvent; 

 

 

            LoggerName = loggerName; 

            if(filter != null) 

            { 

                _traceLevelFilter = filter; 

                _filters.Add(filter); 

            } 

 

 

			// ???? ??? ????? ?????????? 

			if (parentLogger == null) 

			{ 

				_bAsync = true; 

				_queue = new BlockingQueue<LoggerEvent>(); 

				_thread = new Thread(MonitorQueue); 

				_thread.IsBackground = true; 

				_thread.Start(); 

			} 

			else  

			{ 

				_parentLogger = parentLogger; 

				_queue = _parentLogger._queue; 

			} 

		} 

 

 

        /// <summary> 

        /// ????????? ?????? ? ??????? ???????? 

        /// </summary> 

        /// <param name="filter">??????</param> 

        public void AddFilter(IEventFilter filter) 

        { 

            if (filter != null) 

            { 

                _filters.Add(filter); 

            } 


        } 

 

 

		/// <summary> 

		/// ??????? ???????????? ??????????? 

		/// </summary> 

		internal Boolean IsAsync 

		{ 

			get { return _parentLogger == null ? _bAsync : _parentLogger.IsAsync; } 

		} 

 

 

        /// <summary> 

        /// ??????? ??? ???????????? ?????? ? ??????? 

        /// </summary> 

        public ManualResetEvent _queueEnabledEvent = null; 

 

 

		/// <summary> 

		/// ?????????? ??????? ??????? ?? ??????? 

		/// </summary> 

		private void MonitorQueue() 

		{ 

			while (_bAsync) 

			{ 

				try 

				{ 

                    if (_queueEnabledEvent != null) 

                    { 

                        _queueEnabledEvent.WaitOne(); 

                    } 

 

 

				    LoggerEvent logEvent; 

					if (_queue.TryDequeue(out logEvent)) 

					{ 

						try 

						{ 

						    EventDispatcher.Dispatch(logEvent); 

						} 

						catch(Exception ex) 

						{ 

							// ???????? ? ??????? 

							Console.WriteLine("<{0}>: ? ???????? ???????????? ???????????????? ????????? ??????????: {1}", 

								logEvent[LoggerEvent.LOGGERNAME_PROPERTY], ex); 

 

 

							// ?????????? ???????????? ??? ?????????? ? ??????? ????????? 

							while (_queue.TryDequeue(0, out logEvent)) 

							{ 


								try 

								{ 

									EventDispatcher.Dispatch(logEvent); 

								} 

								catch (Exception exeption) 

								{ 

									// ???????? ? ??????? 

									Console.WriteLine("<{0}>: ?? ?????????? ???????, ????????? ??????????: {1}", 

										logEvent[LoggerEvent.LOGGERNAME_PROPERTY], exeption); 

								} 

							} 

 

 

                            throw; 

                        } 

					} 

					else 

					{ 

						// ??????? ??????? (??????? Dispose) 

						break; 

					} 

				} 

				catch 

				{ 

					// ???? ??? ??????????? ??????????? ???????? ??????????, ?? ????????? ? ?????????? ????? 

					// NOTE: ??? ???? ????? ???????? ?????? 

					_bAsync = false; 

					Console.WriteLine("<{0}>: ??????????? ??????????? ?????????, ????? ???????????? ?????????? ?????", 

						LoggerName); 

				} 

			} 

		} 

 

 

        /// <summary> 

        /// ?????????????? ????? ??????? ? ????????? ?????? 

        /// </summary> 

        /// <param name="logEvent">???????</param> 

	    private static void RedirectMessageToApplicationLogger(LoggerEvent logEvent) 

	    { 

	        logEvent[LoggerEvent.MESSAGE_PROPERTY] = 

	            "<" + logEvent[LoggerEvent.LOGGERNAME_PROPERTY] + ">: " + 

	            logEvent[LoggerEvent.MESSAGE_PROPERTY]; 

	        CoreApplication.Instance.Logger.Log(logEvent); 

	    } 

 

 

        /// <inheritdoc/> 

        public bool IsAcceptedByEventType(LoggerEvent logEvent) 

        { 


            if(_traceLevelFilter != null) 

            { 

                return _traceLevelFilter.Accepted(logEvent); 

            } 

 

 

            return true; 

        } 

 

 

        /// <inheritdoc/> 

		public void Log(LoggerEvent logEvent) 

		{ 

			try 

			{ 

                logEvent[LoggerEvent.LOGGERNAME_PROPERTY] = LoggerName; 

 

 

			    foreach (IEventFilter filter in _filters) 

			    { 

			        if(!filter.Accepted(logEvent)) 

			        { 

			            return; 

			        } 

			    } 

 

 

                if (IsAsync && !_queue.IsClosed) 

				{ 

					_queue.Enqueue(logEvent); 

				} 

				else 

				{ 

                    EventDispatcher.Dispatch(logEvent); 

				} 

			} 

			catch (Exception ex) 

			{ 

				String message = IsAsync 

                    ? "?????? ??? ????????? ??????? ? ??????? {0} ?? ??????????? ???????????: {1}" 

				    : "?????? ??? ?????? ? ?????? {0}: {1}"; 

 

 

                if (this != CoreApplication.Instance.Logger) 

                { 

                    //  ???? ??? ?? ?? ???? 

                    CoreApplication.Instance.Logger.LogError(message, LoggerName, ex); 

                    RedirectMessageToApplicationLogger(logEvent); 

                } 

                else 


                { 

                    // ????? ????????????? ?? ??????? 

                    Console.WriteLine(message, LoggerName, ex); 

                } 

			} 

		} 

 

 

		public void Dispose() 

		{ 

			if (_queue != null && _parentLogger == null) 

			{ 

				// ??????? ??????? ??????? ?? ????? ????? ??????? 

				_queue.Close(); 

				try 

				{ 

					// ???????? 1 ??????? (1000 ??) ???? ??????? ?? ???????? 

					if (!_queue.EmptiedWaitHandle.WaitOne(TimeSpan.FromMilliseconds(1000), false)) 

					{ 

                        if (this != CoreApplication.Instance.Logger) 

                        { 

                            //  ???? ??? ?? ?? ???? 

                            CoreApplication.Instance.Logger.LogError( 

                                "?? ??????? ????????? ??????????? ??????? ??????? {0}. ???????? ???????: {1}",  

                                LoggerName, _queue.Count); 

                        } 

                        else 

                        { 

                            // ????? ????????????? ?? ??????? 

                            Console.WriteLine("?? ??????? ????????? ??????????? ??????? ??????? {0}. ???????? ???????: {1}", 

                                LoggerName, _queue.Count); 

                        } 

					} 

				} 

				catch(ObjectDisposedException) 

				{} 

				_queue.Dispose(); 

			} 

		} 

	} 

}


